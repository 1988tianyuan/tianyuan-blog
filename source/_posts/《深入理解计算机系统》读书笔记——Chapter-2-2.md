title: 《深入理解计算机系统》读书笔记——Chapter 2(2)
author: 天渊
tags:
  - csapp
categories:
  - 读书笔记
date: 2019-09-11 14:53:00
---
第二章`信息的表示和处理` 第二部分读书笔记

第二部分是对整数的运算规则和浮点数的表示做一些讲解
<!--more-->

目录：

- 整数运算
- 浮点


### 整数运算

#### 无符号加法

使用无符号加法需要注意溢出的情况，下列无符号short求和最后结果就发生了溢出，同样产生了截断，实际结果比理想的结果少了2^16^

```c
unsigned short c = 44444 + 22222;
printf("a is %u, b is %u, result is %u", a, b, c);
```

最后结果为1130，想要的结果是66666

#### 补码加法

大部分时间进行数值计算都是对补码进行操作，在进行补码加法时需要考虑当结果太大或者太小时会不会发生溢出的情况

与无符号加法类似，如果加法结果超过当前数值类型的位数范围时会发生正溢出（太大）或者负溢出（太小）：

![](http://img.mantian.site/201909101634_839.png)

```c
short c = -22222 + (-22222);
printf("a is %u, b is %u, result is %u", a, b, c);
```

其结果为21092，发生了负溢出，其结果比想要的结果大了65536，也就是2^16^

以下函数无法判断两个有符号补码数相加是否发生了溢出：

```c
int check_overflow_short_add(int a, int b) {
    int c = a + b;
    return (c - a) == b && (c - b) == a;
}
```

两个补码a和b相加得到结果c，不管有没有溢出，c-a的结果始终还是b，c-b的结果始终还是a

#### 无符号乘法

无符号乘法也存在高位截断的问题：

```c
unsigned short a = 222;
unsigned short b = 333;
unsigned short c = a * b;
printf("%d", c);
```

理想结果为73926，实际得到的结果为8390，说明溢出的部分被截断了，只剩下了低16位的数据，也就是少了2^16^

#### 补码乘法

补码乘法与无符号乘法差不多，与补码加法一样也需要注意正溢出和负溢出截断的问题

#### 对于某些常数乘法的优化

乘法运算在大多数计算机上都是一个相当慢的运算，需要消耗过多的时钟周期，因此编译器对常数乘法运算会进行一些优化，用移位或者加法运算来代替常数因子的乘法运算

`移位优化`：某个数与2的幂作乘法就可以进行移位运算，`X * 2^k`就可以直接将X左移k位

`加法优化`：将乘数拆散为2的幂次的和，比如`X * 14`就可以拆为`X * (2^3 + 2^2 + 2)`，然后再用移位计算各个部分的值，最后再统一相加

### 浮点数

现代计算机采用`IEEE浮点数标准`来处理带小数点的数字

#### 二进制表示小数

与整数的二进制表示法类似，带小数的数字是用2的负幂次叠加来进行表示，比如5.75就可以拆散为：

`4 + 0 + 1 + 1/2 + 1/4`，用二进制进行表示就是：`101.11`

二进制用以下规则表示带小数的数字，整数部分就是2的正幂次，小数部分就是2的负幂次：

![](http://img.mantian.site/201909111019_571.png)

**缺陷**：可以看出，二进制表示小数无法做到像十进制这么精确，像1/5这种小数通过十进制可以表示为0.2，但是用二进制的话只能通过增加二进制小数位数构造一个近似值来逼近，例如`0.00110011`这个二进制小数转换为十进制是`0.19921875`，已经很接近了

#### IEEE浮点数表示法

在二进制定点表示法的基础上，IEEE标准用以下公式来存储一个浮点数：

<img src="http://img.mantian.site/201909111339_460.png" style="zoom: 67%;" />

各个参数解释如下：

- `s`：符号标记，无论是float还是double类型都是有符号数，s为1则表示负数，s为0表示正数
- `M`：尾数，保存浮点数的实际有效位，其大小是`1 <= M < 2`，以`1.1101`这样的形式展示；不过存储的时候会省略小数点左边的1，只存储右边的位，我们把保留下来的小数点右边的位称为`f`
- `E`：阶码，对尾数M进行加权，判断M的小数点需要左移或者右移多少位，最终计算得到真正的浮点数二进制表示

计算机系统保存浮点数就是对这三个参数分别进行编码保存到固定的位数中，float类型保存到32位长度中，double类型则保存到64位长度中

**float & double**：单精度浮点（float）和双精度浮点（double）除了最高位的符号位s，剩下的区别主要体现在对M和E的保存位数不一样：

- `float`：E取8位，M取23位
- `double`：E取11位，M取52位

以32位的float为例讲一下编码保存各个参数的规则：

- 编码s：保存为1或者0
- 编码E：E的值即要表现2的正幂次，也要表现2的负幂次，而编码保存后的八位数`e`只能是无符号整数，范围是0 ~ 2^8^-1=255，因此E的真实取值范围需要在这个基础上做一个2^7^-1=127的偏移处理，也就是说`e = E + 127`
- 编码M：省略掉M小数点左边的1，只保留小数点右边的23位，也就是`f`

基于这个基本表示规则，有四种不同的情况，以32位float为例：

- `E编码保存的值(e)不为0或者255(2^8-1)`：这种情况即为普通情况，E的取值范围是`-126 ~ 127`
- `e所有位都为0`：称为非规格化值，规定这种情况在解码时舍弃掉M小数点左边的1，只保留`f`；这种情况一般时拿来表示正0或者负0，或者非常逼近于0的小数
- `e所有位都为1 & f所有位为0`：无穷大数，s为1是负无穷，s为0是正无穷
- `e所有位都为1 & f不为0`：NaN，用来表现不是数字（无意义的数字）的情况

**例子**：以float类型`1.25`为例，计算机系统中使用32位二进制`00111111101000000000000000000000`来保存1.25

<img src="http://img.mantian.site/201909111448_137.png" style="zoom:75%;" />

如图：

1. 符号位s为0，表示正数
2. 阶码位e有8位，其值是127，因此`E = 127 - 127 = 0`，阶码E为0
3. 尾数位f有23位，其值是二进制0.01，也就是1/(2^2^) = 1/4

最终值`V = 1 * (1/(2^2)) * 1 = 1.25`