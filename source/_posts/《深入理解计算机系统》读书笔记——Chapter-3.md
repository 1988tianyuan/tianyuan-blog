title: 《深入理解计算机系统》读书笔记——Chapter 3
author: 天渊
tags:
  - csapp
categories:
  - 读书笔记
date: 2019-09-17 10:50:00
---
第三章：`程序的机器级表示`

本章将会了解：

1. C语言代码是如何编译为汇编指令，讲解其中的一些编译器优化行为
2. 汇编指令在机器级的实现，包括栈结构进行过程间数据和控制的传递和局部变量的存储，并学习机器级是如何实现数组这样的数据结构

<!--more-->

### 程序的编码

编译器编译c文件生成的包含汇编指令的s文件，汇编指令已经包含了具体的机器级指令的执行过程，相对于二进制可执行文件而言，汇编指令更加易于阅读，并且能够体现一些在c语言中隐藏的处理器状态

一个程序内包含以下几部分内容：`可执行的机器码`，`操作系统需要的一些信息`，`管理过程调用和返回的运行时栈`，`用户分配的内存块（malloc等）`

> **虚拟地址空间的规范**：
>
> x86-64中，地址的寻址范围最高虽然为2^64^-1，不过在目前的视线中地址的高16位必须设置为0，所以一个地址能够指定的是2^48^或64TB范围内的一个字节

有如下的C语言代码`mstore.c`：

```c
long mult2(long, long);
void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

将这段代码进行编译得到`mstore.o`，再使用反汇编器objdump进行反编译得到如下的汇编代码：

```bash
0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 89 d3                mov    %rdx,%rbx
   4:   e8 00 00 00 00          callq  9 <multstore+0x9>
   9:   48 89 03                mov    %rax,(%rbx)
   c:   5b                      pop    %rbx
   d:   c3                      retq
```

这段汇编代码包含了`mstore.c`程序需要执行的全部指令，左边是机器码指令，右边是汇编指令，机器码和汇编指令在同一个系统中总是一一对应的，其中某些指令结尾的`q`可以忽略

现在另外再编写一个包含main函数的文件`main.c`，用于执行：

```c
#include <stdio.h>
void multstore(long, long, long *);
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %d\n", d);
    return 0;
}
```

编译器需要将`main.c`和`mstore.c`两个文件的函数进行链接：

```bash
[root@localhost ~]# gcc -Og -o prog main.c mstore.c
```

编译为可执行文件`prog`后再用`objdump`进行反编译，反编译完成后的结果包含`multstore`函数对应的汇编指令：

```bash
000000000040056b <multstore>:
  40056b:       53                      push   %rbx
  40056c:       48 89 d3                mov    %rdx,%rbx
  40056f:       e8 b9 ff ff ff          callq  40052d <mult2>
  400574:       48 89 03                mov    %rax,(%rbx)
  400577:       5b                      pop    %rbx
  400578:       c3                      retq   
  400579:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
```

可以看到，链接后的`multstore`与之前未链接的`multstore`有两个不同点：

- 第三行`call`指令调用mult2函数时，调用地址变成了具体的函数地址`40052d`
- 最后加上了一个占位指令`nop`，没有实际意义，只是回了让函数代码变为16字节，一个存储器优化

### 访问信息

这一部分主要讲的是cpu通过寄存器执行指令的具体过程

#### 寄存器

上面的汇编指令例子中有诸如`%rdx`和`%rbx`这样的标识，代表的是x86架构最早的8个寄存器，标号从`%rax`一直到`%rbp`

IA32架构扩展到x86-64架构后，除了将原来的8个寄存器扩展为64位，还增加了8个寄存器，命名从`%r8`到`%r15`

以下是这16个寄存器的具体表示，其中像`%eax`和`%ebx`这类是32位寄存器标号，像`%ax`和`%bx`这类是16位寄存器标号，像`a1`和`b1`这类是8位寄存器标号，不同的寄存器标号对应了当前寄存器上指定低位的字节数据，这些都是为了兼容以前8位，16位和32位机器上编译的程序

<img src="http://img.mantian.site/201909161543_84.png" style="zoom:80%;" />

图中，右边是每个寄存器对应的不同的角色

在x86-64机器上，如果某段程序生成了低位指令，例如生成了一个2字节16位的`%ax`指令，需要以`%rax`这个寄存器为目标，那么高48位的字节怎么处理？有两条规则：

- 对于8位和16位的指令，保持剩下的高位字节数不变
- 对于32位的指令，给剩下32位的字节数置为0

#### 指令的操作数格式

一个指令具体要干啥？多数情况下就是将某个数据放置到某个寄存器或者内存位置，或者将某个数据从某个位置读出，放到某个寄存器或者内存中，这时候就引入了`操作数`的概念，指定某个操作中需要使用的`源数据`（可以是常数或者某个地址）和放置结果的`目的位置`

**`操作数`如何指定源数据？**

- `立即数`：立即数也就是常数，用`$`符号后面跟着数字的方式表示：`$0x1F`

- `寄存器`：操作数位于某个寄存器上，表示方式是直接指定某个寄存器标号`ra`，然后用`R[ra]`来表示这个寄存器存储的值，比如上述例子中的某条指令就是将`%rdx上的数据移动到`%rbx`上： `mov  %rdx,%rbx`

- `内存`：指定内存上操作数的过程相对来说就比较复杂了，需要涉及到以下4个参数：`立即数偏移Imm`， `基址寄存器rb`，`变址寄存器ri`，`比例因子s`；计算有效内存地址的公式是：

  <img src="http://img.mantian.site/201909161624_428.png" style="zoom:50%;" />

  也就是一个立即数加上`基址寄存器`保存的值，再加上`变址寄存器`保存的值乘以一个偏移比例因子

  通过以下这种格式来表示某个内存操作数：

  <img src="http://img.mantian.site/201909161628_844.png" style="zoom:80%;" />

  其中，四个参数并不需要全部出现，有时候会省略个别参数，以下是内存操作数格式表，其他所有情况都是最后一种的特殊情况：

  ![](http://img.mantian.site/201909161630_895.png)

  

了解了以上三种操作数形式，就可以计算出下列操作数表示的具体值了：

>  已知寄存器`%rcx`保存的值是`0x1`，`%rdx`保存的值是`0x3`，求`260(%rcx, %rdx, 2)`这个操作数表示的值？
>
> 根据上述公式，这个操作数对应的地址值应该是`260 + 1 + 3 * 2 = 267`，转换为16进制就是`0x10B`，也就是说这个操作数对应的是内存`0x10B`处的数据

**8字节寄存器**：x86-64中，总是以8字节的寄存器如`%rax`等来表示某个内存的地址

#### 数据传送指令

现在，有了数据位置（寄存器和内存）和操作数，就需要具体的指令来挪动这些数据了

计算机系统中最频繁的就是将一数据从一个位置复制到另一个位置的指令，也就是`MOV`指令，该指令在复制数据时不会做任何修改操作；`MOV`指令根据操作的字节位数还细分为以下几种，其中一个字代表2字节：

![](http://img.mantian.site/201909161654_300.png)

如果需要对寄存器的数据进行以上操作，对应的寄存器标号的字节位数必须与`mov`指令的最后字符相匹配，比如说操作4字节的寄存器`%eax`，需要的指令是`movl`

如果源寄存器和目的寄存器的大小不一致怎么处理？`movz`系列的命令就能将较小的源寄存器数据复制到较大的寄存器，复制完成后会将高位填充为0，其中指令结尾两个符号分别表示源寄存器大小和目标寄存器大小：

![](http://img.mantian.site/201909171627_383.png)

`movz`复制到较大寄存器后，只能将剩余的高位全部用0填充，会忽略掉源数据的符号；`movs`系列的指令与`movz`类似，不过在进行扩展时会考虑源数据的符号位，如果源数据最高位是1，则将目标寄存器剩余的最高位全部设置为1

![](http://img.mantian.site/201909161745_573.png)

如上，`movs`指令最后两位也是表示源寄存器大小和目标寄存器大小；最后一个`cltq`指令只能以`%eax`作为源，以`%rax`作为目标，仅仅作符号扩展用

**内存无法直接复制**：x86-64规定，不能使用`mov`指令直接将数据从一个内存地址复制到另一个内存地址，只能先复制到寄存器

##### 数据传送指令示例

如下有这么一段C程序，将y赋值给指针变量`*xp`，最后返回`*xp`的旧值：

```c
long exchange(long *xp, long y) {
    long x = *xp;
    *xp = y;
    return x;
}
```

用`gcc -Og -S`命令生成过渡汇编代码后，可以看到exchange函数被编译为如下的汇编指令：

```
movq    (%rdi), %rax
movq    %rsi, (%rdi)
ret
```

这段代码执行的过程如下：

1. 使用`movq`命令从`%rdi`这个寄存器记录的内存地址位置上（也就是`*xp`指针指向的内存）复制8个字节的数字到`%rax`寄存器
2. 使用`movq`命令从`%rsi`上复制8个字节的数字（也就是`y`）到`%rdi`记录的内存地址
3. 最后使用`ret`命令将`%rax`寄存器的值返回 （`%rax`一般就是用来保存函数返回值）

**思考**：如果需要用汇编指令实现以下程序，具体指令应该是怎样的？

```c
char *a;
int *b;
*a = -127;
int *b = (int) *a;
```

首先在c语言规范中，如果要将低位数的有符号类型强制转换为高位数的有符号类型，需要先扩充位数，然后再按照高位数的方式读取，所以具体汇编指令如下，假设`*a`保存在`%rdi`上，`*b`保存在`%rsi`上：

```assembly
movsbl	(%rdi), %rax	// 从(%rdi)读取一个字节复制到%rax上然后进行符号填充
movl	%rax, (%rsi)	// 读取4字节到(%rsi)内存
```

因为`char`类型默认是有符号的，因此扩展时需要进行有符号扩展，使用`movsbl`指令

#### 压入和弹出栈数据

计算机系统使用`栈`这个数据结构来实现函数的调用过程，涉及到`入栈(push)`和`出栈(pop)`的指令，每次入栈或者出栈操作都是对栈顶进行操作

- `pushq`：将8字节的数字压入栈顶，对应一个操作数即需要压入的数据源
- `popq`：将8字节的数字弹出栈顶，也是只有一个操作数即弹出的数据的目的地

内存中`栈`这个数据结构可以当成一个数组，方向是由上往下的，栈顶在底部，地址最小，栈底在顶部，地址最大，因此如果是需要对某个8字节的数字进行`入栈`操作，就得先获取栈顶地址，然后将地址减去8得到一个新的地址，然后把数字放入这个新地址

假设，我们现在有个数字存放于`%rax`上，我们先将他入栈，执行的指令是`%pushq  %rax`，然后将他出栈放到`%rdx`，执行指令`%pushq  %rdx`，栈顶指针保存于`%rsp`，具体过程如下：

![](http://img.mantian.site/201909171557_719.png)

1. 首先，需要找到压栈后数据在栈中的地址，也就是在原栈顶`0x108`的基础上减去8，得到新栈顶的地址`0x100`
2. 然后，将`%rax`的数据复制到栈顶，也就是`0x100`这个位置，入栈操作就完成了
3. 最后，将`0x100`位置的数据复制到`%rdx`，将栈顶地址加上8，出栈操作也就完成了