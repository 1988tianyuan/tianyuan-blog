title: 《深入理解计算机系统》读书笔记——Chapter 12(1)
author: 天渊
tags:
  - csapp
categories:
  - 读书笔记
date: 2019-12-15 12:47:00
---
何为并发？CPU处理指令时的逻辑控制流在时间上重叠就是`并发（Concurrency）`，计算机系统大量存在这种异步处理的情况，例如在进行耗时I/O操作时CPU会同时运行其他程序来提高CPU利用率，或者计算机响应人机交互时的异步事件，或者一个并发的web服务器可以同时处理多个client请求
<!--more-->
### 多进程并发编程

像Apache或者Nginx这样的web服务器是基于多进程并发模型以支持大规模的网络请求

多进程模型的web服务器在处理多个请求时大致过程如下：

1. 主进程监听一个server socket描述符`3`，接受一个客户端请求，生成一个client socket连接描述符`4`
2. 主进程fork一个子进程，该子进程拥有父进程描述符表的拷贝
3. 子进程不需要监听描述符`3`，关闭这个描述符，使用描述符`4`与客户端通信
4. 主进程不需要与客户端通信，关闭连接描述符`4`，继续监听描述符`3`

在这个过程中，父进程关闭分配给子进程的描述符`4`这个操作至关重要，否则会内存泄漏

按照以上过程，父进程持续不断地监听客户端请求并 fork子进程，多个子进程并发地为客户端服务

> 进程的优劣：
>
> 父进程和子进程拥有各自独立的描述符表，共享文件表，由于是不同的进程因此拥有相互隔离的虚拟地址空间，这么做既有好处又有坏处，好处是不用担心父子进程相互覆盖对方的虚拟内存，但缺点在于不同的进程想要通信的话只能通过IPC进程间通信，开销较高

### I/O多路复用并发编程

I/O多路复用的优点在于同一个进程能够响应多个I/O事件，不至于因为处理某个连接的读或写阻塞了，而耽误对其他连接的处理

传统的多路复用编程使用`select`函数，内核会在进程注册了select后将进程挂起，只有当一个或者多个连接产生了I/O事件后才将控制权返还给进程，此时进程就可以对这些就绪的I/O事件进程处理，这些事件既可以是read事件也可以write事件，还可以是connect事件，这种方式就是`并发事件驱动(event--driven)`

`select`函数在检测到描述符集合中的某个描述符产生了新的状态，就会立即返回，用户需要遍历这个描述符集合中的每个描述符来判断哪个描述符产生了事件，并进行处理

> select的方式需要用户自己轮询判断哪个描述符产生了事件，而且对最大描述符数有限制（默认是1024），因此后续在Linux平台上产生了更加好用epoll方式，epoll是真正的事件驱动模型，调用epoll后，内核会把具体哪个流产生了什么样的事件告诉给用户，极大地提高了性能

#### I/O多路复用技术的优劣

多路复用技术一个很明显的优点就是在单个进程中就能处理多个client的请求，并且多个I/O流可以共享进程上下文，使得共享数据变得更容易，并且不用开启多个进程处理请求使得资源利用率更高

但多路复用技术在提高了性能的同时带来了编码的复杂度，并且如果当前进程在处理某个I/O流时耗时过长，会耽误对其他client请求的处理

### 多线程并发编程

现代操作系统中，一个进程可以包含多个`线程(thread)`，每个线程都有自己的上下文：线程ID，栈，栈指针，程序计数器等

多个线程在进行工作时，操作系统同样会进行基于时间片的线程上下文切换，保证一个线程不会因为耗时任务而占用太多的CPU时间

在C语言中，多线程是基于`Posix`标准的`pthread`进行编程，由于Java线程模型也是基于操作系统线程模型的，因此和C语言线程模型差别不大，在Java中的`new Thread()`创建的线程相当于当前线程调用`pthread_create()`函数生成子线程，在该子线程终止后需要主线程回收子线程的内存资源，主线程通过`pthread_join()`函数等待子线程运行结束并回收资源

在`Posix`线程模型中还有一个分离线程的方式来生成一个新的线程`pthread_detach()`，这个新线程是不可join的，也不能被主线程杀死，不过优点就是该新线程的资源可以由操作系统回收