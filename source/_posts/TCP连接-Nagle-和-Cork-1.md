title: TCP连接 - Nagle 和 Cork
author: 天渊
tags:
  - TCP
  - 计算机网络
categories:
  - 基础知识
date: 2019-02-13 15:02:00
---
TCP连接涉及到的参数设置及调优策略纷繁多样，其中跟到数据包发送策略有关的有`Nagle算法`和`Cork算法`，这两种算法的都涉及到化TCP通讯过程中的小数据包传输优化，初学时感觉很类似，不容易区分，需要一探究竟
<!-- more -->

### Nagle有什么用

TCP/IP网络传输的发送端，在某些场景下可能会在短时间发送大量小数据包，导致网络拥塞（例如`糊涂窗口综合症`），`Nagle算法`初衷就是想解决这样的问题。TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。如果在数据包中，除开协议头后实际的数据尺寸太小，此类小数据包大量堆积会造成极大的网络拥塞，因此`Nagle`算法决定降低此类小包的发送频率，希望每次都能够以`MSS尺寸`的数据块来发送数据，或者在当前窗口还存在未Ack的数据包时，延迟发送后续的数据包，避免网络中充斥着许多小数据块。

`Nagle算法`的逻辑流程：

![](/blog/images/nagle.jpg)

### Nagle的劣势

`Nagle算法`并没有阻止小包发送，只是阻止了短时间内大量小包的发送，而且在某种程度上降低了数据实时性

`Nagle算法`与TCP接收端的`延迟ACK`策略在某些情况下会造成冲突，极大的降低数据实时性：

> tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发时候，发现ack尚未发送，则立即单独发送

如果`Nagle算法`和`延迟ACK`同时在发送端和接收端存在，则会造成以下现象：

1. 写-写-读的场景，发送端首先发送了小数据包A
2. 接收端接收到数据包A，延迟本次ACK待下一次发送数据时再一并将ACK发送回去
3. 发送端未收到数据包A的ACK，因此进行等待，暂不发送后续的数据包B
4. 双方僵持，直到发送端或接收端等待超时

如果对数据实时性要求高而且网络资源充足的情况下可以将其关闭，例如在Netty中可以对Channel设置`TCP_NODELAY`属性来关闭Nagle功能：

```java
bootstrap.childOption(ChannelOption.TCP_NODELAY, true)
```



### Cork算法有什么用

`Nagle算法`并没有完全解决小数据包问题，仅仅是解决了发送大量小包带来的网络拥塞问题，但`Cork算法`的出现就能很好地降低小数据包带来的影响

`Cork算法`和`Nagle算法`非常类似，但是它们的着眼点不一样，CORK算法则是为了提高网络的利用率，使得总体上协议头占用的比例尽可能的小，方法是如果当前数据包小于MSS大小，则在缓冲区等待，待后续数据包到来时合并未同一个数据包，将小包合并为大包共享一个协议头，这样就达到了消灭小包的目的

通过设置`TCP_CORK`来开启`Cork算法`，并如果开启了`Cork算法`的话，`Nagle`算法也是默认开启的