title: 《深入理解计算机系统》读书笔记——Chapter 9
author: 天渊
tags:
  - csapp
categories:
  - 读书笔记
date: 2019-11-06 23:10:00
---
第九章：虚拟内存

本章对虚拟内存的知识进行了讲解，虚拟内存是操作系统为进程访问内存数据提供的一层抽象，便于程序更方便地管理属于自己的内存数据
<!--more-->

#### 为什么需要虚拟内存

 在以往的认知中，通常都以为程序使用的内存直接就是计算机硬件的那个内存，但如果所有运行的程序直接使用共享内存的话会出现一些问题：

- 程序如果能直接访问内存不安全，比如一个进程操作了另一个进程申请的内存，则会发生不可预知的错误，操作系统并不希望一个用户应用程序拥有直接访问内存的权利
- 系统中运行的程序太多的话，很容易就会把内存占满了，如果有新启动的程序则无法顺利的获得内存空间，这是需要避免的

因此，操作系统使用`虚拟内存（Vitual Memory）`这一概念，对屏蔽了底层实际物理内存，抽象出一层来让用户访问，用户操作的只能是这个虚拟内存地址空间

在程序看来，就好像自己拥有整个内存空间，而在操作系统的角度看，用户申请和使用哪块内存完全是操作系统虚拟化后的结果，对此，操作系统虚拟内存做了以下工作，来更好的服务于应用程序：

- 虚拟内存管理的辖区**不仅限于物理内存**，而且还包括**一部分磁盘空间**，它把物理内存当作磁盘地址空间的一个大型缓存，应用程序的一些不活跃的内存数据会被转移到磁盘上进行存储，也不会存在用户新启动程序而没有足够的内存进行申请的情况，操作系统根据需要在磁盘和内存之间来回传送数据，而这个过程是对用户程序屏蔽的
- 虚拟内存为每个进程提供了**一致的地址空间**，简化了应用程序管理内存的过程
- 每个进程拥有自己**单独隔离的虚拟地址空间**，不会被其他进程影响

### 物理寻址和虚拟寻址

可以把物理内存看成一个很大的字节数组，每个字节都有一个唯一的数组索引，也就是字节的`物理地址`，早期计算机都使用物理地址来进行寻址，现代计算机在物理地址空间之上做了一层虚拟话，称之为虚拟内存，现在的程序都是使用`虚拟地址（Vitual Address）`来管理虚拟内存上存储的字节数据

![](http://img.mantian.site/201911071134_260.png)

CPU使用寻你地址发起发起虚拟寻址，需要通过CPU芯片上自带的`内存管理单元(MMU)`来将虚拟地址翻译为实际的物理地址，而这个地址映射关系存放在主内存中（称之为`页表（Page Table）`）

### 地址空间

把物理内存比喻成字节数组，那这个数组索引的有序集合就叫`物理地址空间`，而相应的，虚拟内存地址对应的字节数组的索引有序集合就叫`虚拟地址空间`，每个进程都有自己对应的`虚拟地址空间`

系统中允许每个字节数据拥有不同的独立的地址，对应不同的地址空间，比如一个字节数据可以有一个对应物理地址空间的物理地址以及一个对应某个进程虚拟地址空间的虚拟内存地址

### 虚拟内存的页缓存

操作系统将虚拟内存以`虚拟页（Vitual Page）`的方式进行组织，每一页都是一个大小固定的数据块

总体上来看，虚拟内存机制是把磁盘作为主要存储区域，而把物理内存作为缓存，相应的，在磁盘和物理内存中就以`物理页（Physical Page）`的方式来存储虚拟内存保存的页数据，因此一个进程的虚拟地址空间同一时间总会有三个不同的部分：

1. `未分配的虚拟内存`：这部分空间是还没有被程序使用的地址空间，从物理上来讲没有与任何一块数据相关联
2. `缓存的虚拟内存页`：这部分虚拟页保存在物理内存上
3. `未缓存的虚拟内存页`：这部分虚拟页保存在磁盘上

下图就是描述虚拟内存是如何在磁盘和硬盘上进行组织的，每一格都代表一个虚拟页：

![](http://img.mantian.site/201911071352_505.png)

其中`未分配的`虚拟页不占有任何存储空间，`已缓存的`虚拟页存储在物理内存上，而剩下的`未缓存的`虚拟页仍旧保存在磁盘上

#### 页表

前文提到，CPU的MMU是根据`页表`将虚拟地址翻译为具体的物理地址，再根据物理地址寻找具体的数据，操作系统会为每一个进程维护一份与之配套的虚拟地址空间的`页表`

页表由多个`页表条目（Page Table Entry）`以及每个条目对应的`有效位 `组成，其中`页表条目`简称`PTE`，条目中存储了某个虚拟页的物理地址，而有效位如果为1表示该PTE地址表示的物理内存的地址，为0则表示要么还未分配，要么保存于磁盘上

##### 页命中

MMU如何根据页表来寻找虚拟页对应的具体地址？这就是页命中的过程

页表和当前进程的虚拟内存地址空间总是一一对应的，每一个PTE都对应一个虚拟页（VP），如果想找到虚拟页VP2的具体物理地址，过程如下：

![](http://img.mantian.site/201911071445_849.png)

首先找到VP2地址所对应的页表PTE，发现当前有效位是1，表示VP2已经缓存在了物理内存上，则该PTE存储的地址就是VP2虚拟页所对应的物理页的具体地址

##### 缺页交换

那如果当前PTE有效位为1呢？表示当前VP不在物理内存中，而存储在磁盘上，这就是通常所说的`缺页`，需要根据PTE存储的当前VP的磁盘地址去找到具体的页数据，然后将磁盘上的VP复制回物理内存中，最后修改PTE的有效位和存储的地址值，再交给MMU处理，此时MMU就能正常命中该VP了

具体的缺页处理过程示例如下：

1. MMU需要寻找VP3的具体地址，但有效位是0，触发缺页中断，交给缺页异常处理程序进行处理

![](http://img.mantian.site/201911071501_172.png)

2. 缺页异常处理程序会选择一个牺牲页VP4，将VP4复制到磁盘并修改VP4对应的PTE，将有效位修改为0，并保存VP4的磁盘地址
3. 随后，异常处理程序将VP3复制到之前存放VP4的物理地址位置，并修改VP3的PTE的有效位和地址值，完成后如下：

![](http://img.mantian.site/201911071508_51.png)

4. 处理完成后，异常处理程序将控制权交还给用户程序，MMU就能正常的命中VP3的物理内存地址了

以上缺页处理的过程称为**按需页面调度**

那向系统新申请一个内存页是什么过程呢？系统会直接在当前虚拟内存对应的磁盘空间上新创建一块区域，并更新这块虚拟内存页对应的PTE，将有效位设置为0并保存对应的磁盘位置，待真正使用这块内存时才进行上述的页面调度过程将需要的虚拟页交换出来

> **局部性原理**：
>
> 虚拟内存的页面调度机制看上去性能会很差，毕竟缺页处理的开销很大，其实操作系统利用局部性原理可以将开销压缩到最小，因为在任意时刻应用程序都趋向于在一个较小的工作集（working set）上工作，这个工作集包含了程序使用频率最高的一部分虚拟页，经过一段初始开销后工作集中的虚拟页都被调度到了物理内存中，大部分时候都能命中

#### 多进程的虚拟页管理

操作系统为每个进程单独管理自己的虚拟地址空间和页表，多个进程的不同的虚拟页面还可以映射到同一个共享的物理内存页面上

虚拟地址机制对多进程的内存管理有显而易见的好处：

- 简化程序内存管理：每个进程的虚拟地址空间都具有**相同的内存格式**，比如代码段和数据段等地址段的大小和起始位置都是相同的，不会与其他进程的内存管理产生冲突，并且链接器生成的可执行文件（包含指令的具体地址）也可以独立于物理内存实际的代码和数据位置，提高了可执行文件的移植性
- 简化加载：操作系统加载文件时，加载器为代码和数据分配虚拟页，将对应页表PTE的有效位设置为0，此时加载器并没有加载实际的数据，待真正使用这部分数据时才从磁盘调用需要的数据页
- 简化共享：有一部分系统调用代码保存于内核中一个共享的内存区域，并将所有进程虚拟地址空间中适当的虚拟页映射到这块共享的内存区域，这样就避免了每个虚拟内存必须得保存同样的内核代码
- 简化内存分配：程序调用malloc等申请内存的系统调用时，系统会直接在虚拟内存空间上分配一系列连续的虚拟页给程序，而这部分虚拟页在实际物理内存上极有可能是分散的

#### 内存访问许可

虚拟内存作为程序到真实内存区域的访问媒介，自然就提供了一种保护机制，限制程序对某些内存的访问权限，比如可读或者可写，这些信息以`许可位`的形式保存在页表的PTE中：

![](http://img.mantian.site/201911071640_705.png)

如上，`SUP`表示进程是否必须运行在内核模式下才能访问该页，`READ`表示当前页对进程是否可读，`WRITE`表示当前页对进程是否可写，比如进程j如果运行在用户模式下，就拥有读VP0以及读写VP2的权限，但没有访问VP1的权限

如果某条指令违反许可操作了某页，将会产生`短错误（segmentation fault）`异常

### 地址翻译

















